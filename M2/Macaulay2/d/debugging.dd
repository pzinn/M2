use parse;
use util;
use tokens;
use common;
use evaluate;

disassembleCode(c:Code):Expr := ( -- add locations?
     when c
     is x:Error do Expr(Sequence(toExpr("error"), x.message))
     is x:sequenceCode do Expr(Sequence(toExpr("sequence"),list(new Sequence len length(x.x) do foreach s in x.x do provide toExpr(s))))
     is x:listCode do Expr(Sequence(toExpr("list"),list(new Sequence len length(x.y) do foreach s in x.y do provide toExpr(s))))
     is x:arrayCode do Expr(Sequence(toExpr("array"),list(new Sequence len length(x.z) do foreach s in x.z do provide toExpr(s))))
     is x:angleBarListCode do Expr(Sequence(toExpr("angleBarList"),list(new Sequence len length(x.t) do foreach s in x.t do provide toExpr(s))))
     is x:semiCode do Expr(Sequence(toExpr("semi"),list(new Sequence len length(x.w) do foreach s in x.w do provide toExpr(s))))
     is x:integerCode do toExpr(x.x)
     is x:realCode do toExpr(x.x)
     is x:unaryCode do Expr(Sequence(toExpr("1-OP"),SymbolBody(getUnopName(x.f)),
               list(Sequence(
	       toExpr(x.rhs)))
	       ))
     is x:binaryCode do Expr(Sequence(toExpr("2-OP"),SymbolBody(getBinopName(x.f)),
               list(Sequence(
               toExpr(x.lhs),
	       toExpr(x.rhs)
	       ))))
     is x:ternaryCode do Expr(Sequence(toExpr("3-OP"),SymbolBody(getTernopName(x.f)),
               list(Sequence(
               toExpr(x.arg1),
	       toExpr(x.arg2),
	       toExpr(x.arg3)
	       ))))
     is x:multaryCode do Expr(Sequence(toExpr("OP"),SymbolBody(getMultopName(x.f)),
               list(new Sequence len length(x.args) do foreach c in x.args do provide toExpr(c))
	       ))
     is x:adjacentCode do Expr(Sequence(toExpr("adjacent"),
               list(Sequence(
               toExpr(x.lhs),
	       toExpr(x.rhs)
	       ))))
     is x:functionCode do Expr(Sequence(toExpr("function"),
               list(Sequence(
	       Sequence(toExpr("restargs"),toExpr(x.desc.restargs)),
	       Sequence(toExpr("numparms"),toExpr(x.desc.numparms)),
	       Sequence(toExpr("framesize"),toExpr(x.desc.framesize)),
	       Sequence(toExpr("frameID"),toExpr(x.desc.frameID)),
	       Sequence(toExpr("body"),toExpr(x.body))
	       ))))
     is x:globalAssignmentCode do Expr(Sequence(
     	        toExpr("global-assign"),
		SymbolBody(x.lhs),
		toExpr(x.lhs.frameindex),
		list(Sequence(toExpr(x.rhs)))
		))
     is x:localAssignmentCode do Expr(Sequence(
                toExpr("local-assign"),toExpr(x.frameindex),toExpr(x.nestingDepth),
		list(Sequence(toExpr(x.rhs)))
		))
     is x:parallelAssignmentCode do Expr(Sequence(
                toExpr("parallel-assign"),
		list(list(new Sequence len length(x.nestingDepth) do
			 for i from 0 to length(x.nestingDepth)-1 do
			 if x.lhs.i == dummySymbol
			 then provide Expr(Sequence(toExpr(x.frameindex.i),toExpr(x.nestingDepth.i)))
			 else provide Expr(Sequence(SymbolBody(x.lhs.i),toExpr(x.lhs.i.frameindex)))
			 ),
			 toExpr(x.rhs))
		))
     is x:augmentedAssignmentCode do Expr(Sequence(
                toExpr("augmented-assign"),
		SymbolBody(x.oper),
		list(Sequence(toExpr(x.lhs),toExpr(x.rhs)))
		))
     is x:globalMemoryReferenceCode do Expr(Sequence(toExpr("global-fetch"),toExpr((x.frameindex))))
     is x:localMemoryReferenceCode do Expr(Sequence(toExpr("fetch"),toExpr(x.frameindex),toExpr(x.nestingDepth)))
     is x:threadMemoryReferenceCode do Expr(Sequence(toExpr("thread-fetch"),toExpr((x.frameindex))))
     is x:forCode do Expr(Sequence(toExpr("for"),
               list(Sequence(
	       Sequence(toExpr("framesize"),toExpr(x.framesize)),
	       Sequence(toExpr("frameID"),toExpr(x.frameID)),
	       Sequence(toExpr("in"),toExpr(x.inClause)),
	       Sequence(toExpr("from"),toExpr(x.fromClause)),
	       Sequence(toExpr("to"),toExpr(x.toClause)),
	       Sequence(toExpr("when"),toExpr(x.whenClause)),
	       Sequence(toExpr("list"),toExpr(x.listClause)),
	       Sequence(toExpr("do"),toExpr(x.doClause))))
	       ))
     is x:whileListDoCode do Expr(Sequence(toExpr("while"),
               list(Sequence(
               toExpr(x.predicate),
	       Sequence(toExpr("list"),toExpr(x.listClause)),
	       Sequence(toExpr("do"),toExpr(x.doClause))))
	       ))
     is x:whileDoCode do Expr(Sequence(toExpr("while"),
               list(Sequence(
               toExpr(x.predicate),
	       Sequence(toExpr("do"),toExpr(x.doClause))))
	       ))
     is x:whileListCode do Expr(Sequence(toExpr("while"),
               list(Sequence(
               toExpr(x.predicate),
	       Sequence(toExpr("list"),toExpr(x.listClause))))
	       ))
     is x:newOfFromCode do Expr(Sequence(toExpr("new"),
               list(Sequence(
               toExpr(x.newClause),
	       Sequence(toExpr("of"),toExpr(x.ofClause)),
	       Sequence(toExpr("from"),toExpr(x.fromClause))
	       ))
	       ))
     is x:newFromCode do Expr(Sequence(toExpr("new"),
               list(Sequence(
               toExpr(x.newClause),
	       Sequence(toExpr("from"),toExpr(x.fromClause))
	       ))
	       ))
     is x:newOfCode do Expr(Sequence(toExpr("new"),
               list(Sequence(
               toExpr(x.newClause),
	       Sequence(toExpr("of"),toExpr(x.ofClause))
	       ))
	       ))
     is x:newCode do Expr(Sequence(toExpr("new"),
               list(Sequence(
               toExpr(x.newClause)
	       ))
	       ))
     is x:ifCode do Expr(Sequence(toExpr("if"),
               list(Sequence(
               toExpr(x.predicate),
	       Sequence(toExpr("then"),toExpr(x.thenClause)),
	       Sequence(toExpr("else"),toExpr(x.elseClause))
	       ))
	       ))
     is x:tryCode do Expr(Sequence(toExpr("try"),
               list(Sequence(
               toExpr(x.code),
	       Sequence(toExpr("then"),toExpr(x.thenClause)),
	       Sequence(toExpr("else"),toExpr(x.elseClause))
	       ))
	       ))
     is x:catchCode do Expr(Sequence(toExpr("try"),list(Sequence(toExpr(x.code)))))
     is x:globalSymbolClosureCode  do Expr(Sequence(toExpr("global"),SymbolBody(x.symbol),toExpr(x.symbol.frameindex)))
     is x:threadSymbolClosureCode  do Expr(Sequence(toExpr("thread"),SymbolBody(x.symbol),toExpr(x.symbol.frameindex)))
     is x:localSymbolClosureCode do Expr(Sequence(toExpr("local"),SymbolBody(x.symbol),toExpr(x.symbol.frameindex),toExpr(x.nestingDepth)))
     is x:nullCode do Expr(Sequence())
     else toExpr(tostring(c))
     );
disassemble(e:Expr):Expr := (
     when e
     is c:PseudocodeClosure do disassembleCode(c.code)
     is c:Pseudocode do disassembleCode(c.code)
     is s:SpecialExpr do disassemble(s.e)
     else WrongArg("pseudocode")
     );
setupfun("disassemble", disassemble);

pseudocode(e:Expr):Expr := (
     when e
     is f:FunctionClosure do Expr(PseudocodeClosure(f.frame, Code(f.model)))
     is f:functionCode do Expr(Pseudocode(f.body))
     is s:SpecialExpr do pseudocode(s.e)
     else WrongArg("a function derived from Macaulay2 code")
     );
setupfun("pseudocode", pseudocode);

-- locate:
locate(p:Position):Expr := (
	  if p == dummyPosition || p == tempPosition
	  then nullE
	  else Expr(sethash(List(filePositionClass,
	       Sequence(
		    toExpr(verifyMinimizeFilename(p.filename)),
		    toExpr(int(p.line1)),toExpr(int(p.column1)),
		    toExpr(int(p.line2)),toExpr(int(p.column2)),
		    toExpr(int(p.line)),toExpr(int(p.column))),
	       hash_t(0),false),false)));

locate(e:Expr):Expr := (
     when e
     is Nothing do nullE
     is Sequence do locate(lookupfun(e))
     is CompiledFunction do nullE
     is CompiledFunctionClosure do nullE
     is CompiledFunctionBody do nullE
     is s:SymbolClosure do locate(s.symbol.position)
     is c:PseudocodeClosure do locate(codePosition(c.code))
     is c:Pseudocode do locate(codePosition(c.code))
     is s:SpecialExpr do locate(s.e)
     is f:functionCode do locate(f.position)
     is f:FunctionClosure do locate(f.model.position)
     else WrongArg("a function, symbol, sequence, or null"));
setupfun("locate", locate).Protected = false; -- will be overloaded in m2/methods.m2

