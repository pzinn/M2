 -*- coding: utf-8 -*- This is MonodromySolver.info, produced by Macaulay2, version 1.12

INFO-DIR-SECTION Macaulay2 and its packages
START-INFO-DIR-ENTRY
* MonodromySolver: (MonodromySolver).  solving polynomial systems via monodromy
END-INFO-DIR-ENTRY


File: MonodromySolver.info, Node: Top, Next: appendPoint, Up: Top

MonodromySolver -- solve polynomial systems via homotopy continuation and monodromy
***********************************************************************************

Description
===========

This package provides randomized numerical methods for finding complex
solutions to systems of polynomial equations. The main methods implemented in
this package find solutions to polynomial systems of equations over the complex
numbers. As described in "Solving polynomial systems via homotopy continuation
and monodromy" (2016) (see https://arxiv.org/abs/1609.08722 ), these methods
pair numerical homotopy continuation with the transitive monodromy action of a
suitable covering map.

It includes several blackbox functions based on these methods.

  * *note sparseMonodromySolve: sparseMonodromySolve, -- an "out of the box"
    polynomial system solver
  * *note solveFamily: solveFamily, -- a solver for parametric families with
    simple output
  * *note monodromySolve: monodromySolve, -- the main function of the
    MonodromySolver package
  * *note dynamicFlowerSolve: dynamicFlowerSolve, -- a naive dynamic strategy

The most basic interface is provided by the method *note sparseMonodromySolve:
sparseMonodromySolve,. More advanced solvers can be applied to linearly
parametrized families. The family in the example below is the 5-variable Reimer
system from the Posso test suite: the generic solution count is 144, while the
Bezout number and mixed volume are both 720.





+-----------------------------------------------------------------------------+
|i1 : setRandomSeed 0                                                         |
|                                                                             |
|o1 = 0                                                                       |
+-----------------------------------------------------------------------------+
|i2 : R = CC[a_1..a_5,b_1..b_5][x,y,z,t,u]                                    |
|                                                                             |
|o2 = R                                                                       |
|                                                                             |
|o2 : PolynomialRing                                                          |
+-----------------------------------------------------------------------------+
|i3 : P = polySystem {-a_1+b_1*(x^2-y^2+z^2+u^2-t^2),-a_2+b_2*(x^3-y^3+z^3+u^3|
|                                                                             |
|o3 = P                                                                       |
|                                                                             |
|o3 : PolySystem                                                              |
|-----------------------------------------------------------------------------|
|-t^3),-a_3+b_3*(x^4-y^4+z^4+u^4-t^4),-a_4+b_4*(x^5-y^5+z^5+u^5-t^5),         |
|-----------------------------------------------------------------------------|
|-a_5+b_5*(x^6-y^6+z^6+u^6-t^6)}                                              |
+-----------------------------------------------------------------------------+
|i4 : (N,npaths) = monodromySolve P                                           |
|                                                                             |
|o4 = (HomotopyNode{...5...}, 576)                                            |
|                                                                             |
|o4 : Sequence                                                                |
+-----------------------------------------------------------------------------+
|i5 : first N.SpecializedSystem -- (the first polynomial of) a randomly genera|
|                                                                             |
|                              2                          2                   |
|o5 = (- .272372 - .962192*ii)x  + (.272372 + .962192*ii)y  + (- .272372 -    |
|     ------------------------------------------------------------------------|
|                 2                          2                            2   |
|     .962192*ii)z  + (.272372 + .962192*ii)t  + (- .272372 - .962192*ii)u  - |
|     ------------------------------------------------------------------------|
|     .841103 + .540875*ii                                                    |
|                                                                             |
|o5 : CC  [x, y, z, t, u]                                                     |
|       53                                                                    |
|-----------------------------------------------------------------------------|
|ted system in the family defined by P                                        |
+-----------------------------------------------------------------------------+
|i6 : first N.PartialSols -- a solution to N.SpecializedSystem                |
|                                                                             |
|o6 = {.851837+.102702*ii, -.312865+.878644*ii, .053494+.506022*ii,           |
|                                                                             |
|o6 : Point                                                                   |
|-----------------------------------------------------------------------------|
|-.606275-.104337*ii, -.208647-.72906*ii}                                     |
+-----------------------------------------------------------------------------+
|i7 : npaths -- total number of paths tracked in call to monodromySolve       |
|                                                                             |
|o7 = 576                                                                     |
+-----------------------------------------------------------------------------+





Each solver works by assembling randomly generated systems within a *note
HomotopyGraph: HomotopyGraph, and tracking paths between them. They are also
equipped with a number of options, which may be useful for speeding up
computation or increasing the probability of success.

In the example above, the underlying graph is "seeded" automatically. The
current seeding implementation will fail, for instance, in cases where there
are equations without parameters. In such a case, the user may find a seed pair
themselves (see *note monodromySolve(PolySystem,Point,List):
monodromySolve_lpPolySystem_cmPoint_cmList_rp, for an example.)



Authors
=======

  * Timothy Duff <timothy.duff@ncf.edu>
  * Cvetelina Hill <cvetelina.hill@math.gatech.edu>
  * Anders Nedergaard Jensen <jensen@math.au.dk>
  * Kisun Lee <klee669@math.gatech.edu>
  * Anton Leykin <leykin@math.gatech.edu>
  * Jeff Sommars <sommars1@uic.edu>

Version
=======

This documentation describes version 1.11 of MonodromySolver.

Source code
===========

The source code from which this documentation is derived is in the file
MonodromySolver.m2 (see share/Macaulay2/MonodromySolver.m2 ).  The auxiliary
files accompanying it are in the directory MonodromySolver/ (see
share/Macaulay2/MonodromySolver/ ).

Exports
=======

  * Types
      * *note HomotopyGraph: HomotopyGraph,
      * *note HomotopyNode: HomotopyNode,
      * *note PointArray: PointArray, -- a container for solutions
  * Functions and commands
      * *note appendPoint: appendPoint, -- append a point at the end of a
        PointArray
      * *note appendPoints: appendPoints, -- append a list of points at the end
        of a PointArray
      * *note completeGraphAugment: completeGraphAugment, -- augment graph with
        the complete graph structure
      * *note completeGraphInit: completeGraphInit, -- initialize the topology
        of a complete graph
      * *note computeMixedVolume: computeMixedVolume, -- compute mixed volume
        via PHCpack
      * *note createSeedPair: createSeedPair, -- create initial seed for the
        homotopy continuation
      * *note dynamicFlowerSolve: dynamicFlowerSolve, -- a naive dynamic
        strategy
      * *note flowerGraphAugment: flowerGraphAugment, -- augment graph with the
        flower graph structure
      * *note flowerGraphInit: flowerGraphInit, -- solve via monodromy by using
        flower shaped graph
      * *note getTrackTime: getTrackTime, -- elapsed time taken by solver
      * *note homotopyGraph: homotopyGraph, -- HomotopyGraph Constructor
      * *note makeBatchPotential: makeBatchPotential, -- batch sensitive
        potentialE
      * *note monodromySolve: monodromySolve, -- the main function of the
        MonodromySolver package
      * *note pointArray: pointArray, -- constructor for PointArray
      * *note potentialE: potentialE, -- the "expected" potential of an edge
      * *note potentialLowerBound: potentialLowerBound, -- the potential which
        is equal to the minimal number of new points guaranteed to be
        discovered
      * *note selectBestEdgeAndDirection: selectBestEdgeAndDirection, --
        selects edge and direction based on highest potential for obtaining new
        information
      * *note selectRandomEdgeAndDirection: selectRandomEdgeAndDirection, --
        random selection of edge and direction for homotopy
      * *note solveFamily: solveFamily, -- a solver for parametric families
        with simple output
      * *note sparseMonodromySolve: sparseMonodromySolve, -- an "out of the
        box" polynomial system solver
      * *note specializeSystem: specializeSystem, -- specialize parametric
        system at a point in the parameter space.
  * Methods
      * appendPoint(PointArray,Point), see *note appendPoint: appendPoint, --
        append a point at the end of a PointArray
      * appendPoints(PointArray,List), see *note appendPoints: appendPoints, --
        append a list of points at the end of a PointArray
      * getTrackTime(HomotopyGraph), see *note getTrackTime: getTrackTime, --
        elapsed time taken by solver
      * *note indices(PointArray): indices_lpPointArray_rp, -- returns indices
        of a PointArray
      * *note length(PointArray): length_lpPointArray_rp, -- number of items
        stored in a PointArray
      * *note member(Point,PointArray): member_lpPoint_cmPointArray_rp, -- test
        Point membership in a PointArray
      * *note net(PointArray): net_lpPointArray_rp, -- pretty printing
  * Symbols
      * PartialSols, see *note HomotopyNode: HomotopyNode,
      * SpecializedSystem, see *note HomotopyNode: HomotopyNode,
      * AugmentEdgeCount, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * AugmentGraphFunction, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * AugmentNodeCount, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * AugmentNumberOfRepeats, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * BatchSize, see *note MonodromySolverOptions: MonodromySolverOptions,
      * EdgesSaturated, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * GraphInitFunction, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * *note MonodromySolverOptions: MonodromySolverOptions,
      * NumberOfEdges, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * NumberOfNodes, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * NumberOfRepeats, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * Potential, see *note MonodromySolverOptions: MonodromySolverOptions,
      * SelectEdgeAndDirection, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * StoppingCriterion, see *note MonodromySolverOptions:
        MonodromySolverOptions,
      * TargetSolutionCount, see *note MonodromySolverOptions:
        MonodromySolverOptions,

File: MonodromySolver.info, Node: appendPoint, Next: appendPoints, Prev: Top, Up: Top

appendPoint -- append a point at the end of a PointArray
********************************************************

Synopsis
========

  * Usage: appendPoint(A,p)
  * Inputs:
      * A, an object of class *note PointArray: PointArray,
      * p, a *note point: (NAGtypes)Point,


Ways to use appendPoint :
=========================

  * appendPoint(PointArray,Point)

File: MonodromySolver.info, Node: appendPoints, Next: completeGraphAugment, Prev: appendPoint, Up: Top

appendPoints -- append a list of points at the end of a PointArray
******************************************************************

Synopsis
========

  * Usage: appendPoints(A,L)
  * Inputs:
      * A, an object of class *note PointArray: PointArray,
      * L, a *note list: (Macaulay2Doc)List,, 


Ways to use appendPoints :
==========================

  * appendPoints(PointArray,List)

File: MonodromySolver.info, Node: completeGraphAugment, Next: completeGraphInit, Prev: appendPoints, Up: Top

completeGraphAugment -- augment graph with the complete graph structure
***********************************************************************

Description
===========

This is a possible value of the option AugmentGraphFunction of the function
monodromySolve. It will augment the graph while respecting the complete graph
structure, so it should be used in conjunction with flowerGraphInit. To use it,
it is necessary to specify a number of nodes or edges to augment by using
AugmentNodeCount or AugmentEdgeCount.

+-----------------------------------------------------------------------------+
|i1 : R = CC[a,b,c,d][x,y];                                                   |
+-----------------------------------------------------------------------------+
|i2 : polys = polySystem {a*x+b*y^2,c*x*y+d};                                 |
+-----------------------------------------------------------------------------+
|i3 : monodromySolve(polys,GraphInitFunction => flowerGraphInit,              |
|                                                                             |
|o3 = (HomotopyNode{...5...}, 5)                                              |
|                                                                             |
|o3 : Sequence                                                                |
|-----------------------------------------------------------------------------|
|AugmentGraphFunction=>completeGraphAugment,AugmentNodeCount=>1)              |
+-----------------------------------------------------------------------------+

File: MonodromySolver.info, Node: completeGraphInit, Next: computeMixedVolume, Prev: completeGraphAugment, Up: Top

completeGraphInit -- initialize the topology of a complete graph
****************************************************************

Description
===========

This is an option for the function monodromySolve which uses a complete graph.
For instance, the user can choose to have 4 vertices and 2 edges connecting
each pair of vertices. Then the homotopy will run on the complete graph on 4
vertices, where each edge is doubled.

+-----------------------------------------------------------------+
|i1 : R = CC[a,b,c,d][x,y];                                       |
+-----------------------------------------------------------------+
|i2 : polys = polySystem {a*x+b*y^2,c*x*y+d};                     |
+-----------------------------------------------------------------+
|i3 : monodromySolve(polys,GraphInitFunction => completeGraphInit)|
|                                                                 |
|o3 = (HomotopyNode{...5...}, 12)                                 |
|                                                                 |
|o3 : Sequence                                                    |
+-----------------------------------------------------------------+

File: MonodromySolver.info, Node: computeMixedVolume, Next: createSeedPair, Prev: completeGraphInit, Up: Top

computeMixedVolume -- compute mixed volume via PHCpack
******************************************************

Synopsis
========

  * Usage: d = computeMixedVolume polys
  * Inputs:
      * polys, a *note list: (Macaulay2Doc)List,, containing polynomials 
  * Outputs:
      * d, an *note integer: (Macaulay2Doc)ZZ,

Description
===========

Computes mixed volume of a polynomial system. For generic systems of a given
support set, this is the generic root count.

+-----------------------------------------------------------------------------+
|i1 : setRandomSeed 0;                                                        |
+-----------------------------------------------------------------------------+
|i2 : R = CC[x,y];                                                            |
+-----------------------------------------------------------------------------+
|i3 : polys = {x+y^2,x*y+1};                                                  |
+-----------------------------------------------------------------------------+
|i4 : mixedVol = computeMixedVolume polys;                                    |
+-----------------------------------------------------------------------------+
|i5 : sparseMonodromySolve(polySystem polys,TargetSolutionCount=>mixedVol,Numb|
|                                                                             |
|o5 = {{.5-.866025*ii, -.5-.866025*ii}, {.5+.866025*ii, -.5+.866025*ii}, {-1, |
|     ------------------------------------------------------------------------|
|     1}}                                                                     |
|                                                                             |
|o5 : List                                                                    |
|-----------------------------------------------------------------------------|
|erOfNodes=>3)                                                                |
+-----------------------------------------------------------------------------+

Ways to use computeMixedVolume :
================================

  * computeMixedVolume(List)

File: MonodromySolver.info, Node: createSeedPair, Next: dynamicFlowerSolve, Prev: computeMixedVolume, Up: Top

createSeedPair -- create initial seed for the homotopy continuation
*******************************************************************

Synopsis
========

  * Usage: (p0,x0) = createSeedPair PS
  * Inputs:
      * PS, a *note polynomial system: (NAGtypes)PolySystem,, a parametric
        polynomial system
  * *note Optional inputs: (Macaulay2Doc)using functions with optional inputs,:
      * initial parameters
  * Outputs:
      * p0, a *note point: (NAGtypes)Point,, representing a random system
      * x0, a *note point: (NAGtypes)Point,, representing a solution to the
        system defined by p0

Description
===========

The "seed pair" appearing in the output of this function is used to initialize
the *note HomotopyGraph: HomotopyGraph, in blackbox solvers. To diagnose
failures for the parametric solvers, it may be helpful to check that seeding
worked as in the example provided below.

+-----------------------------------------------------------------------------+
|i1 : setRandomSeed 0                                                         |
|                                                                             |
|o1 = 0                                                                       |
+-----------------------------------------------------------------------------+
|i2 : R = CC[a,b,c,d][x,y];                                                   |
+-----------------------------------------------------------------------------+
|i3 : polys = polySystem {a*x+b*y^2,c*x*y+d};                                 |
+-----------------------------------------------------------------------------+
|i4 : (p0,x0) := createSeedPair polys;                                        |
+-----------------------------------------------------------------------------+
|i5 : polys0=specializeSystem(p0,polys);                                      |
+-----------------------------------------------------------------------------+
|i6 : apply(polys0,p->sub(p,{x=>first x0.Coordinates,y=>last x0.Coordinates}))|
|                                                                             |
|o6 = {-1.11022e-16-1.66533e-16*ii, 1.11022e-16+5.55112e-17*ii}               |
|                                                                             |
|o6 : List                                                                    |
+-----------------------------------------------------------------------------+

See also
========

  * *note monodromySolve(PolySystem,Point,List):
    monodromySolve_lpPolySystem_cmPoint_cmList_rp, -- the main function of the
    MonodromySolver package

Ways to use createSeedPair :
============================

  * createSeedPair(PolySystem)
  * createSeedPair(PolySystem,List)

File: MonodromySolver.info, Node: dynamicFlowerSolve, Next: flowerGraphAugment, Prev: createSeedPair, Up: Top

dynamicFlowerSolve -- a naive dynamic strategy
**********************************************

Synopsis
========

  * Usage: (L, npaths) = dynamicFlowerSolve(M,p0,L)
  * Inputs:
      * M, a *note matrix: (Macaulay2Doc)Matrix,, defining polynomial system
      * p0, a *note point: (NAGtypes)Point,, assoiated to a specialized system
      * L, a *note list: (Macaulay2Doc)List,, containing partial solutions
        associated to p0
  * *note Optional inputs: (Macaulay2Doc)using functions with optional inputs,:
      * *note RandomPointFunction => ...: dynamicFlowerSolve_lp_pd_pd_pd_cm
        RandomPointFunction => _pd_pd_pd_rp,,
      * *note StoppingCriterion => ...: MonodromySolverOptions,, 
      * *note TargetSolutionCount => ...: dynamicFlowerSolve_lp_pd_pd_pd_cm
        TargetSolutionCount => _pd_pd_pd_rp,,
  * Outputs:
      * L, a *note list: (Macaulay2Doc)List,
      * npaths, an *note integer: (Macaulay2Doc)ZZ,

Description
===========

Output is verbose. For other dynamic strategies, see *note
MonodromySolverOptions: MonodromySolverOptions,.

+-----------------------------------------------------------------------------+
|i1 : R = CC[a,b,c,d][x,y];                                                   |
+-----------------------------------------------------------------------------+
|i2 : polys = polySystem {a*x+b*y^2,c*x*y+d};                                 |
+-----------------------------------------------------------------------------+
|i3 : (p0, x0) = createSeedPair polys;                                        |
+-----------------------------------------------------------------------------+
|i4 : (L, npaths) = dynamicFlowerSolve(polys.PolyMap,p0,{x0})                 |
|--backup directory created: /var/folders/11/t6mmkf11455d4nt0fn639c6h0000gn/T/|
|     -- 0.00240612 seconds elapsed                                           |
|  H01: 1                                                                     |
|     -- 0.0341097 seconds elapsed                                            |
|  H10: 1                                                                     |
|     -- 0.000348011 seconds elapsed                                          |
|number of paths tracked: 2                                                   |
|found 2 points in the fiber so far                                           |
|     -- 0.0040532 seconds elapsed                                            |
|  H01: 2                                                                     |
|     -- 0.00325992 seconds elapsed                                           |
|  H10: 2                                                                     |
|     -- 0.000576909 seconds elapsed                                          |
|number of paths tracked: 6                                                   |
|found 2 points in the fiber so far                                           |
|     -- 0.0031148 seconds elapsed                                            |
|  H01: 2                                                                     |
|     -- 0.00289691 seconds elapsed                                           |
|  H10: 2                                                                     |
|     -- 0.000462044 seconds elapsed                                          |
|number of paths tracked: 10                                                  |
|found 3 points in the fiber so far                                           |
|     -- 0.00317085 seconds elapsed                                           |
|  H01: 3                                                                     |
|     -- 0.00335115 seconds elapsed                                           |
|  H10: 3                                                                     |
|     -- 0.000636408 seconds elapsed                                          |
|number of paths tracked: 16                                                  |
|found 3 points in the fiber so far                                           |
|     -- 0.00330119 seconds elapsed                                           |
|  H01: 3                                                                     |
|     -- 0.00339334 seconds elapsed                                           |
|  H10: 3                                                                     |
|     -- 0.000643315 seconds elapsed                                          |
|number of paths tracked: 22                                                  |
|found 3 points in the fiber so far                                           |
|     -- 0.00319066 seconds elapsed                                           |
|  H01: 3                                                                     |
|     -- 0.00325792 seconds elapsed                                           |
|  H10: 3                                                                     |
|     -- 0.000620239 seconds elapsed                                          |
|number of paths tracked: 28                                                  |
|found 3 points in the fiber so far                                           |
|     -- 0.00326921 seconds elapsed                                           |
|  H01: 3                                                                     |
|     -- 0.00351554 seconds elapsed                                           |
|  H10: 3                                                                     |
|     -- 0.000645698 seconds elapsed                                          |
|number of paths tracked: 34                                                  |
|found 3 points in the fiber so far                                           |
|                                                                             |
|o4 = ({{.149945+.988694*ii, -.536153+.844121*ii}, {.781262-.624203*ii,       |
|     ------------------------------------------------------------------------|
|     -.462954-.886382*ii}, {-.931207-.364491*ii, .999107+.042261*ii}}, 34)   |
|                                                                             |
|o4 : Sequence                                                                |
|-----------------------------------------------------------------------------|
|M2-12366-0/1                                                                 |
+-----------------------------------------------------------------------------+

File: MonodromySolver.info, Node: flowerGraphAugment, Next: flowerGraphInit, Prev: dynamicFlowerSolve, Up: Top

flowerGraphAugment -- augment graph with the flower graph structure
*******************************************************************

Description
===========

This is a possible value of the option *note AugmentGraphFunction:
MonodromySolverOptions, of the function monodromySolve. It will augment the
graph while respecting the flower graph structure, so it should be used in
conjunction with *note flowerGraphInit: flowerGraphInit,. To use it, it is
necessary to specify a number of nodes or edges to augment by using
AugmentNodeCount or AugmentEdgeCount.

+-----------------------------------------------------------------------------+
|i1 : R = CC[a,b,c,d][x,y];                                                   |
+-----------------------------------------------------------------------------+
|i2 : polys = polySystem {a*x+b*y^2,c*x*y+d};                                 |
+-----------------------------------------------------------------------------+
|i3 : monodromySolve(polys,GraphInitFunction => flowerGraphInit,              |
|                                                                             |
|o3 = (HomotopyNode{...5...}, 5)                                              |
|                                                                             |
|o3 : Sequence                                                                |
|-----------------------------------------------------------------------------|
|AugmentGraphFunction=>flowerGraphAugment,AugmentNodeCount=>1)                |
+-----------------------------------------------------------------------------+

File: MonodromySolver.info, Node: flowerGraphInit, Next: getTrackTime, Prev: flowerGraphAugment, Up: Top

flowerGraphInit -- solve via monodromy by using flower shaped graph
*******************************************************************

Description
===========

This is an option for the function monodromySolve which uses a flower graph.
That is, the seed system is the central vertex of the graph; it is connected to
all other vertices by two paths, thus creating a "petal" for each additional
vertex.

+---------------------------------------------------------------+
|i1 : R = CC[a,b,c,d][x,y];                                     |
+---------------------------------------------------------------+
|i2 : polys = polySystem {a*x+b*y^2,c*x*y+d};                   |
+---------------------------------------------------------------+
|i3 : monodromySolve(polys,GraphInitFunction => flowerGraphInit)|
|                                                               |
|o3 = (HomotopyNode{...5...}, 22)                               |
|                                                               |
|o3 : Sequence                                                  |
+---------------------------------------------------------------+

File: MonodromySolver.info, Node: getTrackTime, Next: HomotopyGraph, Prev: flowerGraphInit, Up: Top

getTrackTime -- elapsed time taken by solver
********************************************

Synopsis
========

  * Usage: t = getTrackTime G
  * Inputs:
      * G, an object of class *note HomotopyGraph: HomotopyGraph,
  * Outputs:
      * t, a *note real number: (Macaulay2Doc)RR,

Description
===========

This only works on graphs which have been modified by a solver.

See also
========

  * elapsedTime (missing documentation) -- time a computation using time
    elapsed

Ways to use getTrackTime :
==========================

  * getTrackTime(HomotopyGraph)

File: MonodromySolver.info, Node: HomotopyGraph, Next: homotopyGraph, Prev: getTrackTime, Up: Top

HomotopyGraph
*************

Description
===========

The graph of systems connected by homotopies. Inherits from *note
MutableHashTable: (Macaulay2Doc)MutableHashTable,.

Keys associated with HomotopyGraph
----------------------------------

  * Edges: a mutable list of edges
  * Family: the parametric system (or null)
  * Potential: the potential function used (or null)
  * Vertices: a mutable list of nodes

See also
========

  * *note HomotopyNode: HomotopyNode,

Functions and methods returning an object of class HomotopyGraph :
==================================================================

  * *note homotopyGraph: homotopyGraph, -- HomotopyGraph Constructor

Methods that use an object of class HomotopyGraph :
===================================================

  * getTrackTime(HomotopyGraph), see *note getTrackTime: getTrackTime, --
    elapsed time taken by solver

For the programmer
==================

The object *note HomotopyGraph: HomotopyGraph, is a *note type:
(Macaulay2Doc)Type,, with ancestor classes *note MutableHashTable:
(Macaulay2Doc)MutableHashTable, < *note HashTable: (Macaulay2Doc)HashTable, <
*note Thing: (Macaulay2Doc)Thing,.

File: MonodromySolver.info, Node: homotopyGraph, Next: HomotopyNode, Prev: HomotopyGraph, Up: Top

homotopyGraph -- HomotopyGraph Constructor
******************************************

Synopsis
========

  * Usage: G = homotopyGraph PS
  * Inputs:
      * PS, a *note polynomial system: (NAGtypes)PolySystem,
  * *note Optional inputs: (Macaulay2Doc)using functions with optional inputs,:
      * *note Family => ...: homotopyGraph_lp_pd_pd_pd_cm Family =>
        _pd_pd_pd_rp,,
      * *note Potential => ...: homotopyGraph_lp_pd_pd_pd_cm Potential =>
        _pd_pd_pd_rp,,
  * Outputs:
      * G, an object of class *note HomotopyGraph: HomotopyGraph,, 


Ways to use homotopyGraph :
===========================

  * homotopyGraph(PolySystem) (missing documentation)

File: MonodromySolver.info, Node: HomotopyNode, Next: indices_lpPointArray_rp, Prev: homotopyGraph, Up: Top

HomotopyNode
************

Description
===========

Object associated to a polynomial system.

Keys associated with HomotopyNode
---------------------------------

  * BasePoint: not exported
  * Edges: a mutable list of edges
  * Graph: a HomotopyGraph containing the node
  * PartialSols: a *note PointArray: PointArray, of associated solutions
  * SpecializedSystem: a list of equations associated to the node

For the programmer
==================

The object *note HomotopyNode: HomotopyNode, is a *note type:
(Macaulay2Doc)Type,, with ancestor classes *note MutableHashTable:
(Macaulay2Doc)MutableHashTable, < *note HashTable: (Macaulay2Doc)HashTable, <
*note Thing: (Macaulay2Doc)Thing,.

File: MonodromySolver.info, Node: indices_lpPointArray_rp, Next: length_lpPointArray_rp, Prev: HomotopyNode, Up: Top

indices(PointArray) -- returns indices of a PointArray
******************************************************

Synopsis
========

  * Usage: indices A
  * Function: *note indices: (Macaulay2Doc)indices,
  * Inputs:
      * A, an object of class *note PointArray: PointArray,


See also
========

  * *note indices: (Macaulay2Doc)indices, -- indices of a polynomial; also
    components for a direct sum

File: MonodromySolver.info, Node: length_lpPointArray_rp, Next: makeBatchPotential, Prev: indices_lpPointArray_rp, Up: Top

length(PointArray) -- number of items stored in a PointArray
************************************************************

Synopsis
========

  * Usage: length A
  * Function: *note length: (Macaulay2Doc)length,
  * Inputs:
      * A, an object of class *note PointArray: PointArray,
  * Outputs:
      * an *note integer: (Macaulay2Doc)ZZ,


See also
========

  * *note length: (Macaulay2Doc)length, -- length

File: MonodromySolver.info, Node: makeBatchPotential, Next: member_lpPoint_cmPointArray_rp, Prev: length_lpPointArray_rp, Up: Top

makeBatchPotential -- batch sensitive potentialE
************************************************

Description
===========

This is a more general *note potentialE: potentialE,, which accounts for the
fact that the expected number of points discovered along an edge depends on the
*note BatchSize: MonodromySolverOptions,.

See also
========

  * *note potentialE: potentialE, -- the "expected" potential of an edge
  * *note MonodromySolverOptions: MonodromySolverOptions,

File: MonodromySolver.info, Node: member_lpPoint_cmPointArray_rp, Next: monodromySolve, Prev: makeBatchPotential, Up: Top

member(Point,PointArray) -- test Point membership in a PointArray
*****************************************************************

Synopsis
========

  * Usage: member(p,A)
  * Function: *note member: (Macaulay2Doc)member,
  * Inputs:
      * p, a *note point: (NAGtypes)Point,
      * A, an object of class *note PointArray: PointArray,


See also
========

  * *note member: (Macaulay2Doc)member, -- test membership in a list or set

File: MonodromySolver.info, Node: monodromySolve, Next: monodromySolve_lpPolySystem_rp, Prev: member_lpPoint_cmPointArray_rp, Up: Top

monodromySolve -- the main function of the MonodromySolver package
******************************************************************

Synopsis
========

  * *note Optional inputs: (Macaulay2Doc)using functions with optional inputs,:
      * *note AugmentEdgeCount => ...: MonodromySolverOptions,, 
      * *note AugmentGraphFunction => ...: MonodromySolverOptions,, 
      * *note AugmentNodeCount => ...: MonodromySolverOptions,, 
      * *note AugmentNumberOfRepeats => ...: MonodromySolverOptions,, 
      * *note BatchSize => ...: MonodromySolverOptions,, 
      * *note EdgesSaturated => ...: MonodromySolverOptions,, 
      * *note GraphInitFunction => ...: MonodromySolverOptions,, 
      * new tracking routine
      * *note NumberOfEdges => ...: MonodromySolverOptions,, 
      * *note NumberOfNodes => ...: MonodromySolverOptions,, 
      * *note NumberOfRepeats => ...: MonodromySolverOptions,, 
      * *note Potential => ...: MonodromySolverOptions,, 
      * *note SelectEdgeAndDirection => ...: MonodromySolverOptions,, 
      * *note StoppingCriterion => ...: MonodromySolverOptions,, 
      * *note TargetSolutionCount => ...: MonodromySolverOptions,, 
      * *note Verbose => ...: MonodromySolverOptions,, 

Description
===========

Ways to use:
------------

  * *note monodromySolve(PolySystem,Point,List):
    monodromySolve_lpPolySystem_cmPoint_cmList_rp, -- the main function of the
    MonodromySolver package
  * *note monodromySolve(PolySystem): monodromySolve_lpPolySystem_rp, -- the
    main function of the MonodromySolver package

Ways to use monodromySolve :
============================

  * *note monodromySolve(PolySystem): monodromySolve_lpPolySystem_rp, -- the
    main function of the MonodromySolver package
  * *note monodromySolve(PolySystem,Point,List):
    monodromySolve_lpPolySystem_cmPoint_cmList_rp, -- the main function of the
    MonodromySolver package

File: MonodromySolver.info, Node: monodromySolve_lpPolySystem_rp, Next: monodromySolve_lpPolySystem_cmPoint_cmList_rp, Prev: monodromySolve, Up: Top

monodromySolve(PolySystem) -- the main function of the MonodromySolver package
******************************************************************************

Synopsis
========

  * Function: *note monodromySolve: monodromySolve,
  * *note Optional inputs: (Macaulay2Doc)using functions with optional inputs,:
      * *note AugmentEdgeCount => ...: MonodromySolverOptions,, 
      * *note AugmentGraphFunction => ...: MonodromySolverOptions,, 
      * *note AugmentNodeCount => ...: MonodromySolverOptions,, 
      * *note AugmentNumberOfRepeats => ...: MonodromySolverOptions,, 
      * *note BatchSize => ...: MonodromySolverOptions,, 
      * *note EdgesSaturated => ...: MonodromySolverOptions,, 
      * *note GraphInitFunction => ...: MonodromySolverOptions,, 
      * new tracking routine
      * *note NumberOfEdges => ...: MonodromySolverOptions,, 
      * *note NumberOfNodes => ...: MonodromySolverOptions,, 
      * *note NumberOfRepeats => ...: MonodromySolverOptions,, 
      * *note Potential => ...: MonodromySolverOptions,, 
      * *note SelectEdgeAndDirection => ...: MonodromySolverOptions,, 
      * *note StoppingCriterion => ...: MonodromySolverOptions,, 
      * *note TargetSolutionCount => ...: MonodromySolverOptions,, 
      * *note Verbose => ...: MonodromySolverOptions,, 

Description
===========

This blackbox solver is similar in usage to *note sparseMonodromySolve:
sparseMonodromySolve,, but with "technical" output.

+-----------------------------------------------------------------------------+
|i1 : R = CC[a,b,c,d][A,B]                                                    |
|                                                                             |
|o1 = R                                                                       |
|                                                                             |
|o1 : PolynomialRing                                                          |
+-----------------------------------------------------------------------------+
|i2 : polys = polySystem {A^2*a+B^2*b,A*B*c+d}                                |
|                                                                             |
|o2 = polys                                                                   |
|                                                                             |
|o2 : PolySystem                                                              |
+-----------------------------------------------------------------------------+
|i3 : setRandomSeed 0;                                                        |
+-----------------------------------------------------------------------------+
|i4 : (V,npaths) = monodromySolve(polys, NumberOfNodes => 3);                 |
+-----------------------------------------------------------------------------+
|i5 : peek V                                                                  |
|                                                                             |
|o5 = HomotopyNode{BasePoint => {-.971549+.236839*ii, .157598                 |
|                  Edges => MutableList{...8...}                              |
|                  Graph => HomotopyGraph{...5...}                            |
|                  PartialSols => {PointArray( 4 points: 0 3                  |
|                                                                             |
|                                                                             |
|                  SpecializedSystem => {(- .971549 + .236839                 |
|-----------------------------------------------------------------------------|
|-.987503*ii, .841103-.540875*ii, -.396553+.918012*ii}                        |
|                                                                             |
|                                                                             |
|1 2 ), {-.555644-.83142*ii, .002423+.999997*ii}, {.83142                     |
|                                                                             |
|     2                          2                                            |
|*ii)A  + (.157598 - .987503*ii)B , (.841103 - .540875*ii                     |
|-----------------------------------------------------------------------------|
|                                                                             |
|                                                                             |
|                                                                             |
|-.555644*ii, .999997-.002423*ii}, {.555644+.83142*ii, -.002423-.999997*ii},  |
|                                                                             |
|                                                                             |
|)A*B - .396553 + .918012*ii}                                                 |
|-----------------------------------------------------------------------------|
|                                          }                                  |
|                                                                             |
|                                                                             |
|{-.83142+.555644*ii, -.999997+.002423*ii}}                                   |
+-----------------------------------------------------------------------------+

File: MonodromySolver.info, Node: monodromySolve_lpPolySystem_cmPoint_cmList_rp, Next: MonodromySolverOptions, Prev: monodromySolve_lpPolySystem_rp, Up: Top

monodromySolve(PolySystem,Point,List) -- the main function of the MonodromySolver package
*****************************************************************************************

Synopsis
========

  * Usage: (N, npaths) = monodromySolve(PS,p0,L)
  * Function: *note monodromySolve: monodromySolve,
  * Inputs:
      * PS, a *note polynomial system: (NAGtypes)PolySystem,, with parametric
        coefficients
      * p0, a *note point: (NAGtypes)Point,, representing a parametrized system
      * L, a *note list: (Macaulay2Doc)List,, containing solutions associated
        to p0, each represented as a *note Point: (NAGtypes)Point,.
  * *note Optional inputs: (Macaulay2Doc)using functions with optional inputs,:
      * *note AugmentEdgeCount => ...: MonodromySolverOptions,, 
      * *note AugmentGraphFunction => ...: MonodromySolverOptions,, 
      * *note AugmentNodeCount => ...: MonodromySolverOptions,, 
      * *note AugmentNumberOfRepeats => ...: MonodromySolverOptions,, 
      * *note BatchSize => ...: MonodromySolverOptions,, 
      * *note EdgesSaturated => ...: MonodromySolverOptions,, 
      * *note GraphInitFunction => ...: MonodromySolverOptions,, 
      * new tracking routine
      * *note NumberOfEdges => ...: MonodromySolverOptions,, 
      * *note NumberOfNodes => ...: MonodromySolverOptions,, 
      * *note NumberOfRepeats => ...: MonodromySolverOptions,, 
      * *note Potential => ...: MonodromySolverOptions,, 
      * *note SelectEdgeAndDirection => ...: MonodromySolverOptions,, 
      * *note StoppingCriterion => ...: MonodromySolverOptions,, 
      * *note TargetSolutionCount => ...: MonodromySolverOptions,, 
      * *note Verbose => ...: MonodromySolverOptions,, 
  * Outputs:
      * N, an object of class *note HomotopyNode: HomotopyNode,
      * npaths, an *note integer: (Macaulay2Doc)ZZ,, reporting the number of
        paths tracked.

Description
===========

Most solvers rely on the manual seeding function *note createSeedPair:
createSeedPair,. The example below demonstrates how one might seed manually
when some equations don't have parameters---ie. the projection map onto the
variables is non-dominant.

+-----------------------------------------------------------------------------+
|i1 : setRandomSeed 0;                                                        |
+-----------------------------------------------------------------------------+
|i2 : S = CC[a,b,c];                                                          |
+-----------------------------------------------------------------------------+
|i3 : R = S[x,w];                                                             |
+-----------------------------------------------------------------------------+
|i4 : (h, f) = (a*x+b*w+c, 3*x^2 - w + 1);                                    |
+-----------------------------------------------------------------------------+
|i5 : x0 = point {{ii_CC,-2}}; -- clearly a zero of f                         |
+-----------------------------------------------------------------------------+
|i6 : l = apply(2,i->random CC);                                              |
+-----------------------------------------------------------------------------+
|i7 : p0 = point({append(l,- sum apply(l, x0.Coordinates,(i,x)->i*x))});      |
+-----------------------------------------------------------------------------+
|i8 : (N, npaths) = monodromySolve(polySystem {h,f},p0,{x0},NumberOfNodes=>3);|
+-----------------------------------------------------------------------------+

File: MonodromySolver.info, Node: MonodromySolverOptions, Next: net_lpPointArray_rp, Prev: monodromySolve_lpPolySystem_cmPoint_cmList_rp, Up: Top

MonodromySolverOptions
**********************

Description
===========

Here are some options for the solvers. The current defaults for a given solver
may be accessed like so:

+------------------------------------------------------------------------+
|i1 : options monodromySolve                                             |
|                                                                        |
|o1 = OptionTable{AugmentEdgeCount => 0                                 }|
|                 AugmentGraphFunction => null                           |
|                 AugmentNodeCount => 0                                  |
|                 AugmentNumberOfRepeats => null                         |
|                 BatchSize => infinity                                  |
|                 EdgesSaturated => false                                |
|                 GraphInitFunction => completeGraphInit                 |
|                 new tracking routine => true                           |
|                 NumberOfEdges => 4                                     |
|                 NumberOfNodes => 2                                     |
|                 NumberOfRepeats => 10                                  |
|                 Potential => null                                      |
|                 SelectEdgeAndDirection => selectRandomEdgeAndDirection |
|                 StoppingCriterion => null                              |
|                 TargetSolutionCount => null                            |
|                 Verbose => false                                       |
|                                                                        |
|o1 : OptionTable                                                        |
+------------------------------------------------------------------------+

List of Options
---------------

  * Augmentation Options (trigger dynamic strategies)
      * AugmentEdgeCount: number of edges added in augmentation step
      * AugmentGraphFunction: see *note flowerGraphAugment: flowerGraphAugment,
        and *note completeGraphAugment: completeGraphAugment,
      * AugmentNodeCount: number of nodes in augmentation step (dynamic
        strategy triggered if >0)
      * AugmentNumberOfRepeats: max number of augmentation steps should be set
        to ensure termination
  * BatchSize: maximum number of solutions tracked across an edge
  * EdgesSaturated: fills correspondence tables after stopping criteria
    satisfied
  * GraphInitFunction: the underlying graph topology, see *note
    completeGraphInit: completeGraphInit, and *note flowerGraphInit:
    flowerGraphInit,
  * NumberOfEdges: number of edges in underlying graph
  * NumberOfNodes: number of nodes in underlying graph
  * NumberOfRepeats: argument for StoppingCriterion
  * Potential: a function that assigns a number to each edge in each iteration,
    indicating its potential for producing new solutions. Current supported
    potential functions are *note potentialE: potentialE, and *note
    potentialLowerBound: potentialLowerBound,
  * SelectEdgeAndDirection: currently accepts either *note
    selectBestEdgeAndDirection: selectBestEdgeAndDirection, or *note
    selectRandomEdgeAndDirection: selectRandomEdgeAndDirection,. Note that the
    former also requires setting
  * StoppingCriterion: eg. stop if no progress has been made
  * TargetSolutionCount: expected/desired number of solutions (overrides
    StoppingCriterion)
  * Verbose: reports progress in each iteration

For the programmer
==================

The object *note MonodromySolverOptions: MonodromySolverOptions, is a *note
symbol: (Macaulay2Doc)Symbol,.

File: MonodromySolver.info, Node: net_lpPointArray_rp, Next: PointArray, Prev: MonodromySolverOptions, Up: Top

net(PointArray) -- pretty printing
**********************************

Synopsis
========

  * Usage: net A
  * Function: *note net: (Macaulay2Doc)net,
  * Inputs:
      * A, an object of class *note PointArray: PointArray,
  * Outputs:
      * a *note net: (Macaulay2Doc)Net,


See also
========

  * *note Net: (Macaulay2Doc)Net, -- the class of all nets and strings

File: MonodromySolver.info, Node: PointArray, Next: pointArray, Prev: net_lpPointArray_rp, Up: Top

PointArray -- a container for solutions
***************************************

Description
===========

PointArray is a data structure that organizes the solutions found by a solver.
Each *note HomotopyNode: HomotopyNode, object V has an assocaciated PointArray
accessed via V.PartialSols. A "fingerprinting" scheme allows for equality of
points to be checked quickly.



Methods that use an object of class PointArray :
================================================

  * appendPoint(PointArray,Point), see *note appendPoint: appendPoint, --
    append a point at the end of a PointArray
  * appendPoints(PointArray,List), see *note appendPoints: appendPoints, --
    append a list of points at the end of a PointArray
  * *note indices(PointArray): indices_lpPointArray_rp, -- returns indices of a
    PointArray
  * *note length(PointArray): length_lpPointArray_rp, -- number of items stored
    in a PointArray
  * *note member(Point,PointArray): member_lpPoint_cmPointArray_rp, -- test
    Point membership in a PointArray
  * *note net(PointArray): net_lpPointArray_rp, -- pretty printing

For the programmer
==================

The object *note PointArray: PointArray, is a *note type: (Macaulay2Doc)Type,,
with ancestor classes *note MutableHashTable: (Macaulay2Doc)MutableHashTable, <
*note HashTable: (Macaulay2Doc)HashTable, < *note Thing: (Macaulay2Doc)Thing,.

File: MonodromySolver.info, Node: pointArray, Next: potentialE, Prev: PointArray, Up: Top

pointArray -- constructor for PointArray
****************************************

Synopsis
========

  * Usage: A = pointArray L
  * Inputs:
      * L, a *note list: (Macaulay2Doc)List,, containing objects of type *note
        Point: (NAGtypes)Point,
  * Outputs:
      * A, an object of class *note PointArray: PointArray,, 


File: MonodromySolver.info, Node: potentialE, Next: potentialLowerBound, Prev: pointArray, Up: Top

potentialE -- the "expected" potential of an edge
*************************************************

Description
===========

This is an option for the Potential option for *note monodromySolve:
monodromySolve, when we use *note selectBestEdgeAndDirection:
selectBestEdgeAndDirection, option to select edge and direction. This option
computes the expected number of new points obtained by tracking points (under
suitable randomness asumptions about the permutations generated by the
underlying graph.) The expected value is computed by the ratio of unmatched
points and the difference between the total solution count and the number of
the known points.

+------------------------------------------------------------------+
|i1 : R = CC[a,b,c,d,e,f,g,h][x,y,z];                              |
+------------------------------------------------------------------+
|i2 : polys = polySystem {a*x+b*y+c*z,d*x*y+e*x*z+f*y*z,g*x*y*z+h};|
+------------------------------------------------------------------+

In here, we need the target number of solutions, and we will use the mixed
volume for that.

+-----------------------------------------------------------------------------+
|i3 : (p0,x0) := createSeedPair polys                                         |
|                                                                             |
|o3 = ({.302305-.0022597*ii, -.104267-.470079*ii, -.151501-.0959349*ii,       |
|     ------------------------------------------------------------------------|
|     -.493959-.451223*ii, .658738+.072703*ii, -.194472-1.31476*ii,           |
|     ------------------------------------------------------------------------|
|     .733494-.676514*ii, .053173+.996422*ii}, {.781262-.624203*ii,           |
|     ------------------------------------------------------------------------|
|     -.462954-.886382*ii, -.272832+.962062*ii})                              |
|                                                                             |
|o3 : Sequence                                                                |
+-----------------------------------------------------------------------------+

We will comput the mixed volume to find the number of solution counts.

+-----------------------------------------------------------------------------+
|i4 : mixedVolume = computeMixedVolume specializeSystem(p0,polys)             |
|                                                                             |
|o4 = 6                                                                       |
+-----------------------------------------------------------------------------+
|i5 : monodromySolve(polys,p0,{x0},SelectEdgeAndDirection=>                   |
|                                                                             |
|o5 = (HomotopyNode{...5...}, 12)                                             |
|                                                                             |
|o5 : Sequence                                                                |
|-----------------------------------------------------------------------------|
|selectBestEdgeAndDirection, Potential=>potentialE,                           |
|-----------------------------------------------------------------------------|
|TargetSolutionCount=>mixedVolume)                                            |
+-----------------------------------------------------------------------------+

See also
========

  * *note selectBestEdgeAndDirection: selectBestEdgeAndDirection, -- selects
    edge and direction based on highest potential for obtaining new information
  * *note potentialLowerBound: potentialLowerBound, -- the potential which is
    equal to the minimal number of new points guaranteed to be discovered
  * *note computeMixedVolume: computeMixedVolume, -- compute mixed volume via
    PHCpack
  * *note Potential: MonodromySolverOptions,

File: MonodromySolver.info, Node: potentialLowerBound, Next: selectBestEdgeAndDirection, Prev: potentialE, Up: Top

potentialLowerBound -- the potential which is equal to the minimal number of new points guaranteed to be discovered
*******************************************************************************************************************

Description
===========

This is an option for the Potential option for *note monodromySolve:
monodromySolve, when we use *note selectBestEdgeAndDirection:
selectBestEdgeAndDirection, option to select edge and direction. This option
observes discovered and undiscovered points first, and then follows the
homotopy which has the minimal number of new points quaranteed to be found.

+-----------------------------------------------------------------------------+
|i1 : R = CC[a,b,c,d][x,y];                                                   |
+-----------------------------------------------------------------------------+
|i2 : polys = polySystem {a*x+b*y^2,c*x*y+d};                                 |
+-----------------------------------------------------------------------------+
|i3 : (V, npaths) = monodromySolve(polys,SelectEdgeAndDirection=>             |
|                                                                             |
|o3 = (HomotopyNode{...5...}, 12)                                             |
|                                                                             |
|o3 : Sequence                                                                |
|-----------------------------------------------------------------------------|
|selectBestEdgeAndDirection, Potential=>potentialLowerBound)                  |
+-----------------------------------------------------------------------------+
|i4 : G = V.Graph;                                                            |
+-----------------------------------------------------------------------------+
|i5 : apply(toList G.Edges,e->e.Potential12)--potentials for all edges of a   |
|                                                                             |
|o5 = {0, 0, 0, 0}                                                            |
|                                                                             |
|o5 : List                                                                    |
|-----------------------------------------------------------------------------|
|given direction                                                              |
+-----------------------------------------------------------------------------+

See also
========

  * *note selectBestEdgeAndDirection: selectBestEdgeAndDirection, -- selects
    edge and direction based on highest potential for obtaining new information
  * *note potentialE: potentialE, -- the "expected" potential of an edge
  * *note HomotopyEdge: HomotopyEdge,

File: MonodromySolver.info, Node: selectBestEdgeAndDirection, Next: selectRandomEdgeAndDirection, Prev: potentialLowerBound, Up: Top

selectBestEdgeAndDirection -- selects edge and direction based on highest potential for obtaining new information
*****************************************************************************************************************

Description
===========

By default, the solver option SelectEdgeAndDirection is set to
selectRandomEdgeAndDirection; it may be changed to selectBestEdgeAndDirection
as shown below. This will return an error unless the option *note Potential:
MonodromySolverOptions, is also set.

+-----------------------------------------------------------------------------+
|i1 : R = CC[a,b,c,d][x,y];                                                   |
+-----------------------------------------------------------------------------+
|i2 : polys = polySystem {a*x+b*y^2,c*x*y+d};                                 |
+-----------------------------------------------------------------------------+
|i3 : (V,npaths) = monodromySolve(polys,SelectEdgeAndDirection=>              |
|                                                                             |
|o3 = (HomotopyNode{...5...}, 12)                                             |
|                                                                             |
|o3 : Sequence                                                                |
|-----------------------------------------------------------------------------|
|selectBestEdgeAndDirection, Potential=>potentialLowerBound)                  |
+-----------------------------------------------------------------------------+

See also
========

  * *note selectRandomEdgeAndDirection: selectRandomEdgeAndDirection, -- random
    selection of edge and direction for homotopy
  * *note potentialLowerBound: potentialLowerBound, -- the potential which is
    equal to the minimal number of new points guaranteed to be discovered
  * *note potentialE: potentialE, -- the "expected" potential of an edge
  * *note HomotopyEdge: HomotopyEdge,
  * *note MonodromySolverOptions: MonodromySolverOptions,

File: MonodromySolver.info, Node: selectRandomEdgeAndDirection, Next: solveFamily, Prev: selectBestEdgeAndDirection, Up: Top

selectRandomEdgeAndDirection -- random selection of edge and direction for homotopy
***********************************************************************************

Description
===========

This is the random edge-selection strategy for solvers. An edge is chosen
uniformly at random from all edges in the underlying *note HomotopyGraph:
HomotopyGraph,, then its direction is chosen randomly. This is currently the
default behavior for all solvers.

See also
========

  * *note selectBestEdgeAndDirection: selectBestEdgeAndDirection, -- selects
    edge and direction based on highest potential for obtaining new information
  * *note HomotopyEdge: HomotopyEdge,
  * *note MonodromySolverOptions: MonodromySolverOptions,

File: MonodromySolver.info, Node: solveFamily, Next: sparseMonodromySolve, Prev: selectRandomEdgeAndDirection, Up: Top

solveFamily -- a solver for parametric families with simple output
******************************************************************

Synopsis
========

  * Usage: (sys,sols) = solveFamily PS
  * Inputs:
      * PS, a *note polynomial system: (NAGtypes)PolySystem,, whose underlying
        coefficient ring is defined by parameters.
  * *note Optional inputs: (Macaulay2Doc)using functions with optional inputs,:
      * *note AugmentEdgeCount => ...: MonodromySolverOptions,, 
      * *note AugmentGraphFunction => ...: MonodromySolverOptions,, 
      * *note AugmentNodeCount => ...: MonodromySolverOptions,, 
      * *note AugmentNumberOfRepeats => ...: MonodromySolverOptions,, 
      * *note BatchSize => ...: MonodromySolverOptions,, 
      * *note EdgesSaturated => ...: MonodromySolverOptions,, 
      * *note GraphInitFunction => ...: MonodromySolverOptions,, 
      * new tracking routine
      * *note NumberOfEdges => ...: MonodromySolverOptions,, 
      * *note NumberOfNodes => ...: MonodromySolverOptions,, 
      * *note NumberOfRepeats => ...: MonodromySolverOptions,, 
      * *note Potential => ...: MonodromySolverOptions,, 
      * *note SelectEdgeAndDirection => ...: MonodromySolverOptions,, 
      * *note StoppingCriterion => ...: MonodromySolverOptions,, 
      * *note TargetSolutionCount => ...: MonodromySolverOptions,, 
      * *note Verbose => ...: MonodromySolverOptions,, 
  * Outputs:
      * sys, a *note list: (Macaulay2Doc)List,, containing the equations of a
        random specialization of PS.
      * sols, a *note list: (Macaulay2Doc)List,, containing solutions to sys,
        each represented as a *note Point: (NAGtypes)Point,.

Description
===========

The output of *note monodromySolve: monodromySolve, is "technical." This method
is intended for users uninterested in the underlying *note HomotopyGraph:
HomotopyGraph, and its satellite data.

+-----------------------------------------------------------------------------+
|i1 : R = CC[a,b,c,d,e,f][x,y];                                               |
+-----------------------------------------------------------------------------+
|i2 : q  = a*x^2+b*y+c;                                                       |
+-----------------------------------------------------------------------------+
|i3 : l = d*x+e*y+f;                                                          |
+-----------------------------------------------------------------------------+
|i4 : (sys, sols) = solveFamily polySystem {q,l}                              |
|                                                                             |
|                              2                                              |
|o4 = ({(.778029 - .628229*ii)x  + (.118767 + .992922*ii)y - .971549 +        |
|     ------------------------------------------------------------------------|
|     .236839*ii, (.157598 - .987503*ii)x + (.841103 - .540875*ii)y - .396553 |
|     ------------------------------------------------------------------------|
|     + .918012*ii}, {{.991984+.222462*ii, .00293132+.0334106*ii},            |
|     ------------------------------------------------------------------------|
|     {-.714825+.738362*ii, .756286-1.5827*ii}})                              |
|                                                                             |
|o4 : Sequence                                                                |
+-----------------------------------------------------------------------------+

Ways to use solveFamily :
=========================

  * solveFamily(PolySystem)
  * solveFamily(PolySystem,Point,List)

File: MonodromySolver.info, Node: sparseMonodromySolve, Next: specializeSystem, Prev: solveFamily, Up: Top

sparseMonodromySolve -- an "out of the box" polynomial system solver
********************************************************************

Synopsis
========

  * Usage: sols = sparseMonodromySolve PS
  * Inputs:
      * PS, a *note polynomial system: (NAGtypes)PolySystem,, whose
        coefficients are complex numbers
  * *note Optional inputs: (Macaulay2Doc)using functions with optional inputs,:
      * *note AugmentEdgeCount => ...: MonodromySolverOptions,, 
      * *note AugmentGraphFunction => ...: MonodromySolverOptions,, 
      * *note AugmentNodeCount => ...: MonodromySolverOptions,, 
      * *note AugmentNumberOfRepeats => ...: MonodromySolverOptions,, 
      * *note BatchSize => ...: MonodromySolverOptions,, 
      * *note EdgesSaturated => ...: MonodromySolverOptions,, 
      * *note GraphInitFunction => ...: MonodromySolverOptions,, 
      * new tracking routine
      * *note NumberOfEdges => ...: MonodromySolverOptions,, 
      * *note NumberOfNodes => ...: MonodromySolverOptions,, 
      * *note NumberOfRepeats => ...: MonodromySolverOptions,, 
      * *note Potential => ...: MonodromySolverOptions,, 
      * *note SelectEdgeAndDirection => ...: MonodromySolverOptions,, 
      * *note StoppingCriterion => ...: MonodromySolverOptions,, 
      * *note TargetSolutionCount => ...: MonodromySolverOptions,, 
      * *note Verbose => ...: MonodromySolverOptions,, 
  * Outputs:
      * sols, a *note list: (Macaulay2Doc)List,, containing solutions to sys,
        each represented as a *note Point: (NAGtypes)Point,.

Description
===========

Blackbox monodromy solver for a square polynomial system without parameters.
The example below finds all six intersection of a generic cubic with its
quadratic polar curve.





+-----------------------------------------------------------------------------+
|i1 : setRandomSeed 0;                                                        |
+-----------------------------------------------------------------------------+
|i2 : R=CC[x,y,z];                                                            |
+-----------------------------------------------------------------------------+
|i3 : F=random(3,R);                                                          |
|-- warning: experimental computation over inexact field begun                |
|--          results not reliable (one warning given per session)             |
+-----------------------------------------------------------------------------+
|i4 : P=sum apply(gens R,g->diff(g,F)*random CC);                             |
+-----------------------------------------------------------------------------+
|i5 : sparseMonodromySolve polySystem {F,P,random(1,R)-1}                     |
|                                                                             |
|o5 = {{.212986+.505809*ii, -.0640254-.418811*ii, .174869+.144954*ii},        |
|     ------------------------------------------------------------------------|
|     {.040931+.735463*ii, -.751621+.636639*ii, -.809224+.075569*ii},         |
|     ------------------------------------------------------------------------|
|     {.453473+.301343*ii, -1.01938-.509842*ii, -.592697-.68244*ii},          |
|     ------------------------------------------------------------------------|
|     {-.147508-.127555*ii, -.071535-.796132*ii, .39264+.652917*ii},          |
|     ------------------------------------------------------------------------|
|     {-1.08883+.94758*ii, -.222671+1.03031*ii, .185791+1.24332*ii},          |
|     ------------------------------------------------------------------------|
|     {.449377+.392627*ii, .105165-.142662*ii, -.21861+.38705*ii}}            |
|                                                                             |
|o5 : List                                                                    |
+-----------------------------------------------------------------------------+

For systems with dense support such as the above, the number of paths tracked
is generally not optimal, though timings may be comparable.



Ways to use sparseMonodromySolve :
==================================

  * sparseMonodromySolve(PolySystem)

File: MonodromySolver.info, Node: specializeSystem, Prev: sparseMonodromySolve, Up: Top

specializeSystem -- specialize parametric system at a point in the parameter space.
***********************************************************************************

Synopsis
========

  * Usage: equations = specializeSystem(p0, PS)
  * Inputs:
      * p0, a *note point: (NAGtypes)Point,, in parameter space
      * PS, a *note polynomial system: (NAGtypes)PolySystem,, with parameters
        as coefficients
  * Outputs:
      * equations, a *note list: (Macaulay2Doc)List,, containing equtaions of
        system with parameters specialized at p0


Ways to use specializeSystem :
==============================

  * specializeSystem(Point,Matrix)
  * specializeSystem(Point,PolySystem)

Tag Table:
Node: Top255
Node: appendPoint12119
Node: appendPoints12574
Node: completeGraphAugment13073
Node: completeGraphInit14742
Node: computeMixedVolume16035
Node: createSeedPair18229
Node: dynamicFlowerSolve21069
Node: flowerGraphAugment27611
Node: flowerGraphInit29327
Node: getTrackTime30566
Node: HomotopyGraph31233
Node: homotopyGraph32507
Node: HomotopyNode33281
Node: indices_lpPointArray_rp34087
Node: length_lpPointArray_rp34610
Node: makeBatchPotential35148
Node: member_lpPoint_cmPointArray_rp35755
Node: monodromySolve36317
Node: monodromySolve_lpPolySystem_rp38358
Node: monodromySolve_lpPolySystem_cmPoint_cmList_rp43804
Node: MonodromySolverOptions47489
Node: net_lpPointArray_rp51309
Node: PointArray51791
Node: pointArray53270
Node: potentialE53692
Node: potentialLowerBound57665
Node: selectBestEdgeAndDirection60526
Node: selectRandomEdgeAndDirection62682
Node: solveFamily63536
Node: sparseMonodromySolve67274
Node: specializeSystem71544

End Tag Table
